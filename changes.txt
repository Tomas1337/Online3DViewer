diff --git a/source/website/highlighttool.js b/source/website/highlighttool.js
index 38adfbd..7b232a1 100644
--- a/source/website/highlighttool.js
+++ b/source/website/highlighttool.js
@@ -19,6 +19,7 @@ export class HighlightTool {
         this.eventsInitialized = null;
         this.activeTouches = 0;
         this.overlappingMeshes = new Map();
+        this.brushSize = 0.05;
     }
 
     InitEvents() {
@@ -330,6 +331,14 @@ export class HighlightTool {
         return point1.distanceTo(point2) < threshold;
     }
 
+    SetBrushSize(size) {
+        if (typeof size === 'number' && size > 0) {
+            this.brushSize = size;
+        } else {
+            console.error('Invalid brush size. Please provide a positive number.');
+        }
+    }
+
     GenerateHighlightMesh(intersection) {
         let mesh = intersection.object;
         let highlightMaterial = new THREE.MeshPhongMaterial({
@@ -346,31 +355,53 @@ export class HighlightTool {
 
         let highlightGeometry = new THREE.BufferGeometry();
         let positions = mesh.geometry.attributes.position;
+        let normals = mesh.geometry.attributes.normal;
+        let highlightPositions = [];
+        let highlightNormals = [];
+
+        // Convert brush size to local space of the mesh
+        let localBrushSize = this.brushSize / mesh.scale.x;
+        let facesFound = 0;
+
+        for (let i = 0; i < positions.count; i += 3) {
+            let a = new THREE.Vector3().fromBufferAttribute(positions, i);
+            let b = new THREE.Vector3().fromBufferAttribute(positions, i + 1);
+            let c = new THREE.Vector3().fromBufferAttribute(positions, i + 2);
+
+            // Calculate face center
+            let faceCenter = new THREE.Vector3().add(a).add(b).add(c).divideScalar(3);
+            let localIntersectionPoint = new THREE.Vector3().copy(intersection.point).applyMatrix4(mesh.matrixWorld.invert());
+
+            // Check if face center is within brush radius
+            if (faceCenter.distanceTo(localIntersectionPoint) <= localBrushSize) {
+                facesFound++;
+                highlightPositions.push(
+                    a.x, a.y, a.z,
+                    b.x, b.y, b.z,
+                    c.x, c.y, c.z
+                );
+
+                // Add corresponding normals
+                let na = new THREE.Vector3().fromBufferAttribute(normals, i);
+                let nb = new THREE.Vector3().fromBufferAttribute(normals, i + 1);
+                let nc = new THREE.Vector3().fromBufferAttribute(normals, i + 2);
+                highlightNormals.push(
+                    na.x, na.y, na.z,
+                    nb.x, nb.y, nb.z,
+                    nc.x, nc.y, nc.z
+                );
+            }
+        }
 
-        let a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
-        a.fromBufferAttribute(positions, intersection.face.a);
-        b.fromBufferAttribute(positions, intersection.face.b);
-        c.fromBufferAttribute(positions, intersection.face.c);
-
-        highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
-            a.x, a.y, a.z,
-            b.x, b.y, b.z,
-            c.x, c.y, c.z
-        ], 3));
-
-        let normal = new THREE.Vector3();
-        normal.crossVectors(b.clone().sub(a), c.clone().sub(a)).normalize();
-        highlightGeometry.setAttribute('normal', new THREE.Float32BufferAttribute([
-            normal.x, normal.y, normal.z,
-            normal.x, normal.y, normal.z,
-            normal.x, normal.y, normal.z
-        ], 3));
+        highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(highlightPositions, 3));
+        highlightGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(highlightNormals, 3));
 
         let highlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
         highlightMesh.applyMatrix4(mesh.matrixWorld);
-        let offset = normal.multiplyScalar(0.001);
-        highlightMesh.position.add(offset);
 
+        let offsetVector = new THREE.Vector3().fromBufferAttribute(normals, intersection.face.a).applyMatrix4(mesh.matrixWorld).normalize().multiplyScalar(0.001);
+        highlightMesh.position.add(offsetVector);
+    
         return highlightMesh;
     }
 
@@ -383,6 +414,12 @@ export class HighlightTool {
             this.SetHighlightColor(event.target.value);
         });
 
+        let brushSizeSlider = AddDiv(this.panel, 'ov_highlight_brush_size');
+        brushSizeSlider.innerHTML = '<input type="range" id="brush-size" min="0.01" max="0.5" step="0.01" value="' + this.brushSize + '">';
+        brushSizeSlider.addEventListener('input', (event) => {
+            this.SetBrushSize(parseFloat(event.target.value));
+        });
+
         let clearButton = AddDiv(this.panel, 'ov_highlight_clear_button');
         clearButton.innerHTML = '<button>Clear Highlight</button>';
         clearButton.addEventListener('click', () => {
