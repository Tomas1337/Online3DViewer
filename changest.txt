diff --git a/source/website/highlighttool.js b/source/website/highlighttool.js
index 290516f..92e9a83 100644
--- a/source/website/highlighttool.js
+++ b/source/website/highlighttool.js
@@ -19,7 +19,8 @@ export class HighlightTool {
         this.eventsInitialized = null;
         this.activeTouches = 0;
         this.overlappingMeshes = new Map();
-        this.brushSize = 0.05;
+        this.brushSize = 5;
+        this.brushSizeSlider = null;
     }
 
     InitEvents() {
@@ -43,6 +44,18 @@ export class HighlightTool {
 
     }
 
+    ShowBrushSizeSlider() {
+        if (this.brushSizeSlider) {
+            this.brushSizeSlider.style.display = 'block';
+        }
+    }
+
+    HideBrushSizeSlider() {
+        if (this.brushSizeSlider) {
+            this.brushSizeSlider.style.display = 'none';
+        }
+    }
+
     addTouchListeners (canvas) {
         canvas.addEventListener('touchstart', (event) => {
             if (this.isActive) {
@@ -83,16 +96,16 @@ export class HighlightTool {
         if (this.isActive === isActive) {
             return;
         }
-    
+
         this.isActive = isActive;
         this.button.SetSelected(isActive);
-        
+
         // Update the viewer button
         let viewerButton = document.getElementById('highlight-button');
         if (viewerButton) {
             viewerButton.classList.toggle('active', isActive);
         }
-    
+
         if (!isActive) {
             this.viewer.navigation.EnableCameraMovement(true);
             this.isNavigating = false;
@@ -102,7 +115,7 @@ export class HighlightTool {
             this.InitEvents();
             this.eventsInitialized = true;
         }
-    
+
         if (this.isActive) {
             this.panel = AddDiv(document.body, 'ov_highlight_panel');
             this.UpdatePanel();
@@ -117,15 +130,17 @@ export class HighlightTool {
 
 
     // Mouse Events
-    Click (mouseCoordinates, button) {
+    Click(mouseCoordinates, button) {
+        if (!this.isActive) return;
+
         let intersection = this.viewer.GetMeshIntersectionUnderMouse(IntersectionMode.MeshOnly, mouseCoordinates);
         if (intersection === null) {
             return;
         }
 
-        if (this.mouseButton === 0) {
+        if (button === 0) {
             this.ApplyHighlight(intersection);
-        } else if (this.mouseButton === 2) {
+        } else if (button === 2) {
             this.RemoveHighlight(intersection);
         }
 
@@ -133,22 +148,21 @@ export class HighlightTool {
     }
 
     MouseMove(mouseCoordinates) {
-        if (!this.isActive) {
-            return;
-        }
+        if (!this.isActive) return;
+
         let intersection = this.viewer.GetMeshIntersectionUnderMouse(IntersectionMode.MeshOnly, mouseCoordinates);
         if (intersection === null) {
-            // No intersection, don't do anything
             return;
         }
-        // Existing highlight logic here
+
         if (this.isMouseDown) {
-            if (this.mouseButton === 0 ) {
+            if (this.mouseButton === 0) {
                 this.ApplyHighlight(intersection);
             } else if (this.mouseButton === 2) {
                 this.RemoveHighlight(intersection);
             }
         }
+
         this.viewer.Render();
     }
 
@@ -196,7 +210,7 @@ export class HighlightTool {
         if (intersection === null) {
             return;
         }
-        
+
         if (this.activeTouches === 1) {
             this.ApplyHighlight(intersection);
         } else if (this.activeTouches === 2) {
@@ -214,70 +228,70 @@ export class HighlightTool {
             this.viewer.navigation.EnableCameraMovement(true);
         }
     }
-    
+
     ApplyHighlight(intersection) {
         let highlightMesh = this.GenerateHighlightMesh(intersection);
-        
+
         // Check for overlapping meshes
         let overlappingMeshes = this.GetOverlappingMeshes(highlightMesh);
-        
+
         if (overlappingMeshes.length >= this.maxOverlappingMeshes) {
             // Remove the oldest overlapping mesh
             let oldestMesh = overlappingMeshes[0];
             this.RemoveHighlight({ point: oldestMesh.position });
             overlappingMeshes.shift();
         }
-        
+
         // Add the new mesh
         HighlightTool.sharedHighlightMeshes.push(highlightMesh);
         this.viewer.AddExtraObject(highlightMesh);
-        
+
         // Update overlapping meshes
         overlappingMeshes.push(highlightMesh);
         this.overlappingMeshes.set(highlightMesh.uuid, overlappingMeshes);
-        
+
         this.viewer.Render();
     }
 
     GetOverlappingMeshes(newMesh) {
         let overlapping = [];
         let newBoundingBox = new THREE.Box3().setFromObject(newMesh);
-        
+
         for (let mesh of this.highlightMeshes) {
             let meshBoundingBox = new THREE.Box3().setFromObject(mesh);
             if (newBoundingBox.intersectsBox(meshBoundingBox)) {
                 overlapping.push(mesh);
             }
         }
-        
+
         return overlapping;
     }
-    
-    RemoveHighlight(intersection) {        
+
+    RemoveHighlight(intersection) {
         if (!intersection || !intersection.point) {
             return;
         }
-    
+
         let meshesToRemove = HighlightTool.sharedHighlightMeshes.filter((mesh) => {
             let boundingBox = new THREE.Box3().setFromObject(mesh);
             boundingBox.expandByScalar(0.01); // Expand the bounding box slightly
             let isWithinBoundingBox = boundingBox.containsPoint(intersection.point);
             return isWithinBoundingBox;
         });
-    
+
         if (meshesToRemove.length === 0) {
             return;
         }
-    
+
         meshesToRemove.forEach((mesh) => {
             this.viewer.RemoveExtraObject(mesh);
-            
+
             // Update highlightMeshes array
             HighlightTool.sharedHighlightMeshes = HighlightTool.sharedHighlightMeshes.filter((m) => m !== mesh);
-            
+
             // Dispose of the highlight mesh
             this.DisposeHighlightMesh(mesh);
-    
+
             // Update overlappingMeshes
             this.overlappingMeshes.delete(mesh.uuid);
             for (let [key, value] of this.overlappingMeshes) {
@@ -285,7 +299,7 @@ export class HighlightTool {
                 this.overlappingMeshes.set(key, filteredValue);
             }
         });
-    
+
         this.viewer.Render();
     }
 
@@ -300,7 +314,7 @@ export class HighlightTool {
     DisposeHighlightMesh(mesh) {
         DisposeThreeObjects(mesh);
         this.viewer.scene.remove (mesh);
-        this.viewer.Render();  
+        this.viewer.Render();
     }
 
     IsIntersectionWithinBoundingBox(intersection, mesh) {
@@ -328,10 +342,48 @@ export class HighlightTool {
     }
 
     SetBrushSize(size) {
-        if (typeof size === 'number' && size > 0) {
-            this.brushSize = size;
-        } else {
-            console.error('Invalid brush size. Please provide a positive number.');
+        this.brushSize = size;
+        // Convert brush size from 1-10 range to actual size (e.g., 0.01 to 0.1)
+        this.actualBrushSize = size / 10;
+    }
+
+    CreateBrushSizeSlider() {
+        const sliderContainer = document.createElement('div');
+        sliderContainer.className = 'brush-size-slider';
+        sliderContainer.style.display = 'none';
+    
+        const slider = document.createElement('input');
+        slider.type = 'range';
+        slider.min = '1';
+        slider.max = '10';
+        slider.value = this.brushSize.toString();
+        slider.style.width = '80%'; // Adjust width to accommodate size display
+        slider.addEventListener('input', (event) => {
+            this.SetBrushSize(parseInt(event.target.value));
+            brushSizeDisplay.textContent = event.target.value + ' px'; // Update display with 'px'
+        });
+    
+        const brushSizeDisplay = document.createElement('span');
+        brushSizeDisplay.className = 'brush-size-display';
+        brushSizeDisplay.textContent = slider.value + ' px'; // Initial display value with 'px'
+    
+        sliderContainer.appendChild(slider);
+        sliderContainer.appendChild(brushSizeDisplay);
+        this.brushSizeSlider = sliderContainer;
+        return sliderContainer;
+    }
+    
+    ShowBrushSizeSlider() {
+        console.log("Showing brush size slider.");
+        if (this.brushSizeSlider) {
+            console.log("Brush size slider is already visible.");
+            this.brushSizeSlider.style.display = 'block';
+        }
+    }
+
+    HideBrushSizeSlider() {
+        if (this.brushSizeSlider) {
+            this.brushSizeSlider.style.display = 'none';
         }
     }
 
@@ -348,27 +400,28 @@ export class HighlightTool {
             polygonOffsetFactor: -1,
             polygonOffsetUnits: -1
         });
-    
+
         let highlightGeometry = new THREE.BufferGeometry();
         let positions = mesh.geometry.attributes.position;
         let normals = mesh.geometry.attributes.normal;
         let highlightPositions = [];
         let highlightNormals = [];
-    
+
         // Convert brush size to local space of the mesh
-        let localBrushSize = this.brushSize / mesh.scale.x;
+        let localBrushSize = this.actualBrushSize / mesh.scale.x;
+        // let localBrushSize = 0.05 / mesh.scale.x;
         let localIntersectionPoint = intersection.point.clone().applyMatrix4(mesh.matrixWorld.invert());
-    
+
         // First pass: collect faces within brush radius
         let facesWithinRadius = new Set();
         for (let i = 0; i < positions.count; i += 3) {
             let a = new THREE.Vector3().fromBufferAttribute(positions, i);
             let b = new THREE.Vector3().fromBufferAttribute(positions, i + 1);
             let c = new THREE.Vector3().fromBufferAttribute(positions, i + 2);
-    
+
             // Calculate face center
             let faceCenter = new THREE.Vector3().add(a).add(b).add(c).divideScalar(3);
-    
+
             // Check if face center is within brush radius
             if (faceCenter.distanceTo(localIntersectionPoint) <= localBrushSize) {
                 facesWithinRadius.add(i / 3);
@@ -382,15 +435,15 @@ export class HighlightTool {
             let a = new THREE.Vector3().fromBufferAttribute(positions, faceIndex * 3);
             let b = new THREE.Vector3().fromBufferAttribute(positions, faceIndex * 3 + 1);
             let c = new THREE.Vector3().fromBufferAttribute(positions, faceIndex * 3 + 2);
-    
+
             // Check adjacent faces
             for (let i = 0; i < positions.count; i += 3) {
                 if (facesToHighlight.has(i / 3)) continue;
-    
+
                 let d = new THREE.Vector3().fromBufferAttribute(positions, i);
                 let e = new THREE.Vector3().fromBufferAttribute(positions, i + 1);
                 let f = new THREE.Vector3().fromBufferAttribute(positions, i + 2);
-    
+
                 // If any vertex of this face is close to any vertex of the current face
                 if (this.ArePointsClose(a, d, localBrushSize) || this.ArePointsClose(a, e, localBrushSize) || this.ArePointsClose(a, f, localBrushSize) ||
                     this.ArePointsClose(b, d, localBrushSize) || this.ArePointsClose(b, e, localBrushSize) || this.ArePointsClose(b, f, localBrushSize) ||
@@ -401,7 +454,7 @@ export class HighlightTool {
         });
 
         console.log("Faces to highlight count: " + facesToHighlight.size);
-        
+
         // Add faces to highlight
         facesToHighlight.forEach(faceIndex => {
             let i = faceIndex * 3;
@@ -490,4 +543,4 @@ export class HighlightTool {
     SetHighlightColor(color) {
         this.highlightColor.set(color);
     }
-}
\ No newline at end of file
+}
diff --git a/source/website/website.js b/source/website/website.js
index 6339abe..3c6cc23 100644
--- a/source/website/website.js
+++ b/source/website/website.js
@@ -647,6 +647,8 @@ export class Website
         this.viewer.SetMouseMoveHandler(this.OnModelMouseMove.bind(this));
         this.viewer.SetMouseUpHandler(this.OnModelMouseUp.bind(this));
 
+        this.viewer.GetCanvas().addEventListener('mouseenter', this.OnCanvasMouseEnter.bind(this));
+        this.viewer.GetCanvas().addEventListener('mouseleave', this.OnCanvasMouseLeave.bind(this));
     }
 
     OnModelMouseDown(mouseCoordinates) {
@@ -689,6 +691,18 @@ export class Website
         }
     }
 
+    OnCanvasMouseEnter() {
+        if (this.highlightTool.IsActive()) {
+            this.highlightTool.ShowBrushSizeSlider();
+        }
+    }
+    
+    OnCanvasMouseLeave() {
+        if (this.highlightTool.IsActive()) {
+            this.highlightTool.HideBrushSizeSlider();
+        }
+    }
+
     InitToolbar ()
     {
         function AddButton (toolbar, imageName, imageTitle, classNames, onClick)
@@ -795,6 +809,19 @@ export class Website
             this.ToggleHighlightTool();
         });
         this.highlightTool.SetButton(this.toolbarHighlightButton);
+        
+        const brushSizeSlider = this.highlightTool.CreateBrushSizeSlider();
+
+        // Modify the highlight button's container
+        const highlightContainer = CreateDiv('highlight-container');
+    
+        // // Move the button into the container
+        highlightContainer.appendChild(this.toolbarHighlightButton.buttonDiv);
+
+        // Add the slider to the container
+        highlightContainer.appendChild(brushSizeSlider);
+        this.toolbar.mainDiv.appendChild(highlightContainer);
+        this.toolbarHighlightButton.buttonDiv.style.margin = '0';
 
         this.toolbarEraserButton = AddPushButton(this.toolbar, 'eraser', Loc('Erase'), ['only_full_width', 'only_on_model'], (isSelected) => {
             this.ToggleEraserTool();
